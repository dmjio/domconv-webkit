-- Split begin/Data.DOM.WBTypes

------------------------------------------------------------------
-- |
-- Module      :  Data.DOM.WBTypes
-- Copyright   :  (c) Dmitry Golubovsky, 2009
-- License     :  BSD-style
-- 
-- Maintainer  :  golubovsky@gmail.com
-- Stability   :  experimental
-- Portability :  portable
-- 
--
--
-- Minimal glue for WebBits and DOM
------------------------------------------------------------------

module Data.DOM.WBTypes (
    castExpr
   ,exprType
   ,(/\)
   ,setjsProperty
  ) where

import WebBits.JavaScript
import qualified Data.Foldable as F
import Control.Monad

-- | Cast a WebBits Javascript expression to the given type. Type is represented
-- by a value of the desired type (ofter "undefined").

castExpr :: b -> Expression a -> Expression b

castExpr b e = fmap (const b) e

-- | Extract a type from an expression.

exprType :: Expression a -> a

exprType e =
  let f y z = NullLit (undefined :: a)
      (NullLit x) = F.foldr f undefined e
  in  x

-- | An infix version of "castExpr" provided for convenience.

(/\) :: Expression a -> b -> Expression b

(/\) = flip castExpr

-- | A helper function to encode a property setter. This function is mostly called
-- from converted IDL files for DOM interfaces.

setjsProperty :: (Monad m) => String -> Expression a -> Expression this -> m (Expression this)

setjsProperty pn pv this = do
  let tht = exprType this
      fun = FuncExpr tht [Id tht "x"] blk
      thv = VarRef tht (Id tht "x")
      blk = BlockStmt tht [setp, retx]
      setp = ExprStmt tht $ AssignExpr tht OpAssign (DotRef tht thv (Id tht pn)) (pv /\ tht)
      retx = ReturnStmt tht (Just thv)
  return $ ParenExpr tht $ CallExpr tht fun [this]

-- Split end

-- Split begin/Data.DOM

------------------------------------------------------------------
-- |
-- Module      :  Data.DOM
-- Copyright   :  (c) Dmitry Golubovsky, 2009
-- License     :  BSD-style
-- 
-- Maintainer  :  golubovsky@gmail.com
-- Stability   :  experimental
-- Portability :  portable
-- 
-- This package provides monadic smart constructors to generate "WebBits.JavaScript.Syntax"
-- internal Javascript representation of code accessing DOM structures in
-- type-safe manner.
--
-- Below is an example of Haskell code which generates Javascript to display
-- traditional Hello World. This example shows that even a simplest 
-- "Control.Monad.Identity" will do. Of course, a more sofisticated Monad
-- might provide more benefits, such as assigning some of expressions to
-- Javascript variables, automatic declaration of functions, etc.
-- 
-- @
-- module Main where
-- import WebBits.JavaScript
-- import Control.Monad
-- import Control.Monad.Identity
-- import Data.DOM
-- import Data.DOM.Dom
-- import Data.DOM.Node
-- import Data.DOM.HTMLDocument
-- main = putStrLn $ show $ pp $ 
--   FunctionStmt undefined (Id undefined \"main\") [] 
--     (ExprStmt undefined $ runIdentity q)
-- q = do
--   d \<- htmlDocument
--   t <- mkText (string \"Hello World\") d
--   b <- getm\'body d
--   addChild t b
-- @
--
-- Below is Javascript generated by this example. All expressions just nest
-- where necessary.
--
-- @ 
-- function main()
-- \{
-- window.document.body.appendChild(window.document.createTextNode(\"Hello World\"));
-- \}
-- @
------------------------------------------------------------------

module Data.DOM (
  -- * Additional DOM support functions
  window
 ,document
 ,htmlDocument
 ,mkText
 ,addChild
  -- * Functions to construct Javascript values
 ,string
 ,number
 ,bool
 ,true
 ,false
) where

import Control.Monad
import Data.DOM.WindowObj
import Data.DOM.Window
import Data.DOM.Dom
import Data.DOM.Html2
import Data.DOM.Node
import Data.DOM.Document
import WebBits.JavaScript

-- | Access the global Window object.

window :: (Monad m) => m (Expression TWindow)

window = return $ VarRef TWindow (Id TWindow "window")

-- | Access the current document. This indeed should be made through the
-- Window interface, but current (incomplete) specification does not
-- provide an easy way for that.

document :: (Monad m) => m (Expression TDocument)

document = return $ VarRef TDocument (Id TDocument "window.document")

-- | Same as above, using the HTMLDocument interface.

htmlDocument :: (Monad m) => m (Expression THTMLDocument)

htmlDocument = return $ VarRef THTMLDocument (Id THTMLDocument "window.document")

-- | A maker function for a TEXT element.

mkText :: (Monad mn, CDocument this) => 
   Expression String -> Expression this -> mn (Expression TText)

mkText = createTextNode

-- | Same as 'appendChild', but with type signature reflecting that returned
-- value is the node added.

addChild :: (Monad m, CNode c, CNode p) => Expression c -> Expression p -> m (Expression c)

addChild = appendChild


-- | Create a Javascript string literal out of a string.

string :: String -> Expression String

string s = StringLit s s

-- | Create a Javascript numeric literal out of a numeric value.

number :: (Integral n) => n -> Expression Double

number n = let d = fromIntegral n in NumLit d d

-- | Create a Javascript boolean literal out of a Boolean.

bool :: Bool -> Expression Bool

bool b = BoolLit b b

-- | Javascript True value

true :: Expression Bool

true = bool True

-- | Javascript False value

false :: Expression Bool

false = bool False


-- Split end

